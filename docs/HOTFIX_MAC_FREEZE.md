# Mac死机问题修复说明 (Hotfix v2.3.1)

## 🚨 问题描述

在高性能 Mac (如 M4 Max, 14核) 上处理超过 1000 个文档时，系统会完全卡死，鼠标无响应，必须强制重启。

## 🔍 根本原因分析

经过代码审查，发现 `src/file_processor.py` 中存在一段"极限策略" (Extreme Strategy) 代码，旨在压榨所有 CPU 性能，但设计过于激进：

1.  **进程爆炸**: 代码尝试启动 `cpu_cores * 10` 个进程。对于 14 核的 M4 Max，这意味着试图启动 **140 个 Python 进程**。这导致了巨大的上下文切换开销和内存耗尽。
2.  **人工负载 (Artificial Load)**: 代码中包含一个 `while` 循环，利用 `math.sqrt` 和 `math.sin` 进行无意义的数学计算，旨在强制 CPU 使用率达到 100%。
    ```python
    # 源代码中的问题片段
    while time.time() - start_time < 0.2:
        for i in range(600):
            computation_result += math.sqrt(abs(pid + i + 1))
    ```
    当 140 个进程同时执行这个死循环时，系统内核被完全阻塞。
3.  **激进扫描**: 目录扫描使用了 250 个线程，产生大量不必要的系统调用。

## 🛠️ 修复方案 (v2.3.1)

我们发布了 v2.3.1 热修复版本，进行了以下更改：

### 1. 限制并发进程数
将最大进程数限制为 `min(cpu_cores, 12)`。
- **保留核心**: 始终为操作系统和 UI 保留至少 2 个核心，防止死机。
- **消除开销**: 避免了数百个进程带来的上下文切换风暴。

### 2. 移除人工负载
**完全删除**了上述的 CPU 空转循环。现在 CPU 只用于实际的文档解析和 OCR 处理。

### 3. 优化扫描线程
将目录扫描线程数从 **250** 降低到 **32**，这是一个在性能和资源消耗之间更平衡的值。

### 4. 安全的进程启动
移除了 `mp.set_start_method('fork', force=True)` 的强制调用，让 Python 选择最安全、最适合当前 OS 的启动方式 (macOS 上通常是 `spawn` 或 `fork`，视版本而定)。

## 📈 修复后效果

- **稳定性**: 系统不再卡死，即使处理数千个文件。
- **性能**: 虽然理论峰值 CPU 使用率下降，但由于消除了巨大的系统开销和无用计算，**实际文档处理吞吐量反而可能提升**。
- **响应性**: 在处理文档时，用户仍可正常操作电脑其他软件。

## 📝 给开发者的建议

- **不要人为制造负载**: 相信操作系统的调度器。
- **控制进程数量**: Python 的多进程开销很大，进程数不应远超 CPU 核心数。通常 `cpu_count()` 或 `cpu_count() - 1` 是最佳选择。
- **保留余量**: 永远不要试图占满 100% 的资源，除非是在专用服务器上且经过严格测试。
